---
title: 其他问题
group:
  title: Interview
---

<!-- TOC -->

- [其他问题](#其他问题)
  - [1. 日常项目题](#1-日常项目题)
  - [2. 有没有了解一些最前言的技术](#2-有没有了解一些最前言的技术)
  - [3. 经常逛的技术论坛有哪些？](#3-经常逛的技术论坛有哪些)
  - [4. 最近在看的书籍有哪些？](#4-最近在看的书籍有哪些)
  - [5. 企业微信实现扫码登录的流程是怎样的？](#5-企业微信实现扫码登录的流程是怎样的)
  - [6. 管理后台的权限怎么做的](#6-管理后台的权限怎么做的)
  - [7. 浏览器的设计和 node 的设计有什么区别？](#7-浏览器的设计和-node-的设计有什么区别)
  - [9. typeof 和 instanceof 的区别](#9-typeof-和-instanceof-的区别)
  - [13. git-flow 有了解过吗](#13-git-flow-有了解过吗)
  - [14. npm 和 yarn 的区别](#14-npm-和-yarn-的区别)
    - [14.1. package.json 中版本号的写法](#141-packagejson-中版本号的写法)
  - [15. 让你从头搭建一个项目，你会怎么做](#15-让你从头搭建一个项目你会怎么做)
  - [16. 常见的数据可视化库](#16-常见的数据可视化库)
  - [17. 怎么约定团队的代码规范](#17-怎么约定团队的代码规范)
  - [18. 怎么提高开发效率](#18-怎么提高开发效率)
    - [18.1. 工具](#181-工具)
    - [18.2. 开发习惯](#182-开发习惯)
  - [19. 单元测试](#19-单元测试)
    - [19.1. 单元测试的优缺点](#191-单元测试的优缺点)
    - [19.2. 单元测试的分类](#192-单元测试的分类)
    - [19.3. 单元测试的工具](#193-单元测试的工具)
    - [19.4. 什么场景下会用到单元测试](#194-什么场景下会用到单元测试)
    - [19.5. 单元测试的原则](#195-单元测试的原则)
    - [19.6. 项目中怎么搭配使用](#196-项目中怎么搭配使用)
  - [20. MVC、MVVM](#20-mvcmvvm)
    - [20.1. MVC](#201-mvc)
    - [20.2. MVVM](#202-mvvm)
  - [21. 代码为什么要重构，是怎么做的](#21-代码为什么要重构是怎么做的)
    - [21.1. 代码为什么要重构](#211-代码为什么要重构)
    - [21.2. 代码怎么重构](#212-代码怎么重构)
  - [22. 说一下腾银财智这个项目](#22-说一下腾银财智这个项目)
    - [22.1. 对代码的质量如何把控](#221-对代码的质量如何把控)
    - [22.2. 你的工作中有哪些技术难点](#222-你的工作中有哪些技术难点)
  - [23. 你觉得你的优势是什么？劣势是什么？](#23-你觉得你的优势是什么劣势是什么)
  - [24. 大前端和微前端](#24-大前端和微前端)
  - [25. nx 是什么](#25-nx-是什么)
  - [26. 怎么实现 pdf 预览](#26-怎么实现-pdf-预览)
  - [27. 说一下埋点怎么做的](#27-说一下埋点怎么做的)
    - [27.1. 埋点数据的上报方式](#271-埋点数据的上报方式)
    - [27.2. 埋点数据丢失怎么解决](#272-埋点数据丢失怎么解决)
  - [28. 你的项目中遇到的最大的问题是什么，怎么解决的](#28-你的项目中遇到的最大的问题是什么怎么解决的)
  - [29. 写一个组件，你会考虑哪些方面？](#29-写一个组件你会考虑哪些方面)
  - [30. 怎么看待华为 od 的，为什么做这么久前端了还来华为 od?](#30-怎么看待华为-od-的为什么做这么久前端了还来华为-od)
    - [30.1. 你对华为的认识，对当前岗位的了解](#301-你对华为的认识对当前岗位的了解)
  - [31. 能否接受公司的工作时间？加班？](#31-能否接受公司的工作时间加班)
  - [32. 你的职业规划是什么？](#32-你的职业规划是什么)
  - [33. 你的期望薪资是多少？](#33-你的期望薪资是多少)
  - [34. 你有什么问题要问我们吗？](#34-你有什么问题要问我们吗)
  - [35. 谈薪技巧](#35-谈薪技巧)

<!-- /TOC -->

# 其他问题

## 1. 日常项目题

- 说一下工作中解决过的比较困难的问题，说一下自己项目中比较有亮点的地方
- 最近项目做的什么？有没有遇到什么问题？怎么解决的？

## 2. 有没有了解一些最前言的技术

- 智能化方向
  - D2C：作为前端领域传统的智能化细分领域，利用机器视觉自动生成代码，关键在于对不同模型的优化。
  - 低代码：低代码领域的规范与约定形成更为重要，阿里开源的 LowCodeEngine 可以作为低代码构建的一个参考，另外与智能化方向的自动生成其实可能更有研究价值。
  - ChatGPT：作为 22 年年底最火的 AI 场景，对于回答等的薅羊毛行为，想必会很快出台禁止方案。但是在前端领域，对于代码方案等进行相关指导还是有一定的借鉴意义的。
- 互动方向:对新交互方式的探索与场景运用
  - 元宇宙：前端作为一种靠近用户的工种，其本身技术也会提供诸如：XR 的形态，在虚拟人物生成等方面，确实还是会有一些研究可能存在。
  - Web3：前端作为 Web 领域的重要一环，在第三世代中，肯定也会有重要的运用场景。个人认为，对于区块链相关的上层应用，如 DApp 等，可能还是有一些发展方向的。
- 中后台方向: 随着单页的瓶颈出现，中后台方向又出现了“分久必合，合久必分”的态势，不论是微前端还是 Islands 架构，其都有一种新瓶装旧酒的感觉。
  - 微前端：目前通用的微前端方案大都以“类 SPA”形式进行创建，其本身在接入其他 SPA 时有着天然的弊端。因而，个人认为真正意义上的“微前端”还尚未出现，私以为或许考虑借鉴下微服务的容器化思维，来真正的实现“微”的效果。
  - Islands：Islands 架构的本质其实是多种渲染方式的选择，从 MPA 到 SPA，又从 SPA 回归到 MPA。其实，个人认为可以基于场景的不同进行不同的选择，资源的合理使用来提供最佳的用户体验。
- 可视化方向
  - 领域图形库：对于可视化领域而言，最重要的其实是图形库的选择和开发，但是对于不同层次的可视化方案，也是构建出基于特定领域的专有图形库，解决一类问题，从而有一定的突破和创新。
  - 3D 图形库：大部分的图形库往往注重与二维图形库的创建，对于三维可视/编辑领域，也是有着十分广阔的场景的。

具体:

- 低代码平台: 是指通过可视化的方式，无需编程即可完成应用开发的平台
  - 阿里的飞冰
  - 腾讯的 Rax
  - 百度的 san
  - 微软的 PowerApps
- devops: Development（开发）和 Operations（运维）组合而成。涵盖了软件开发的全生命周期，包括需求管理、版本控制、持续集成、持续交付、持续部署、配置管理、监控、日志管理、安全管理等。
  - 源代码管理工具: gitlab、github、gitee
  - 持续集成/持续部署测试工具: jenkins、gitlab-ci、travis-ci、github-actions
  - 容器化工具: docker、k8s
  - 云服务: 阿里云、腾讯云、华为云、aws、gcp
  - 自动化配置管理工具: ansible、saltstack
  - 监控告警工具: prometheus、grafana、zabbix、elk
  - 项目管理工具: tapd、coding、jira
- web3d: 3D web 技术，是指在 web 上实现 3D 效果的技术
  - three.js
  - babylon.js
  - Cesium
  - WebGL

## 3. 经常逛的技术论坛有哪些？

- [掘金](https://juejin.cn/)
- [知乎](https://www.zhihu.com/)
- [简书](https://www.jianshu.com/)
- [CSDN](https://www.csdn.net/)
- [github](https://github.com)
- [Stack Overflow](https://stackoverflow.com/)
- [SegmentFault 思否](https://segmentfault.com/)
- [开发者头条](https://toutiao.io/)
- [V2EX](https://www.v2ex.com/)
- [InfoQ](https://www.infoq.cn/)
- [medium](https://medium.com/)
- [dev.to](https://dev.to/)
- [css-tricks](https://css-tricks.com/)

## 4. 最近在看的书籍有哪些？

- JavaScript 高级程序设计（第 4 版）
- JavaScript 语言精粹
- Mysql 必知必会
- css 揭秘

## 5. 企业微信实现扫码登录的流程是怎样的？

- 在企微后台创建应用，配置应用的授权回调域名
- 开发者构造扫码链接，用户扫码后，企业微信会跳转到授权回调域名下的一个页面，同时会带上 code 和 state 参数
  - 扫码链接：`https://open.work.weixin.qq.com/wwopen/sso/qrConnect?appid=APPID&agentid=AGENTID&redirect_uri=REDIRECT_URI&state=STATE`
- 开发者通过 code 获取用户的 access_token 和 userid
- 开发者通过 userid 获取用户的详细信息

## 6. 管理后台的权限怎么做的

- 扫码登录后，如果有多个角色，进入一个角色列表
- 选择角色后，有个全局接口返回当前角色的权限列表
- 根据权限列表，渲染菜单和页面
- 权限列表存储在全局，各个页面通过状态管理获取，控制按钮的显示隐藏
- 如果直接进入某个页面，会先请求权限列表，匹配当前页面的权限，如果没有权限，跳转到无权限页面

## 7. 浏览器的设计和 node 的设计有什么区别？

- 全局环境不同
  - 浏览器是在浏览器的全局环境下运行的，所以有 window、document 等全局变量
  - node 是在 node 的全局环境下运行的，所以没有 window、document 等全局变量
- 事件循环不同
  - 微任务的执行时机不同。
    - 在浏览器的事件循环中，每执行完一个宏任务，就会去检查微任务队列，如果有微任务，就会执行微任务，直到微任务队列为空，才会继续执行下一个宏任务
    - node 事件循环中则是在“上一阶段”执行完，“下一阶段”开始前执行微任务队列中的任务。也就是说，node 中的微任务是在两个阶段之间执行的。
  - process.nextTick()的优先级不同。
    - 在浏览器事件循环中，process.nextTick()属于微任务，而且和其他微任务的优先级是一样的，不存在哪个微任务的优先级高就先执行谁。
    - 在 node 中，process.nextTick()的优先级要高于其他微任务，也就是说，在两个阶段之间执行微任务时，若存在 process.nextTick()，则先执行它，然后再执行其他微任务。
- js 引擎不同
  - nodejs 基于 google v8 引擎做了封装，浏览器是直接使用 v8 引擎
- 模块化不同
  - 浏览器端使用的是 es6 的模块化，node 端使用的是 commonjs 的模块化

## 9. typeof 和 instanceof 的区别

typeof 表示是对某个变量类型的检测，基本数据类型除了 null 都能正常的显示为对应的类型，引用类型除了函数会显示为'function'，其它都显示为 object。

instanceof 主要是用于实例的判断。 `A instanceof B` 用来判断 A 是否为 B 的实例。也可以判断一个实例是否是其父类型或者祖先类型的实例

> 扩展：变量类型

- 基本类型： string, number, boolean, undefined, null, Symbol, bigInt(es10 新增)
- 引用类型： function, array, object

## 13. git-flow 有了解过吗

- 是一个别人定义好的工作流程
- 并不会为 Git 扩展任何新的功能
- 安装 git-flow，会拥有一些扩展命令

## 14. npm 和 yarn 的区别

都是包管理工具，但是有以下区别：

- yarn 会将包缓存到本地，下次安装时会直接从本地安装，而 npm 每次都会从远程仓库下载
- yarn 安装包的速度比 npm 快，因为它是并行下载的
- yarn 用 yarn.lock 文件来锁定依赖包的版本，npm 在 v5.5.0 之后使用了 package-lock.json 文件来锁定依赖包的版本

### 14.1. package.json 中版本号的写法

版本号格式：主版本号.次版本号.修订号

- `^1.2.3` 表示安装 1.x.x 版本的最新版本，但不包括 1.0.0
- `~1.2.3` 表示安装 1.2.x 版本的最新版本，但不包括 1.2.0
- `1.2.3` 表示安装 1.2.3 版本
- `*` 表示安装最新版本

## 15. 让你从头搭建一个项目，你会怎么做

- 项目初始化
  - 选择合适的脚手架工具，比如 vue-cli、create-react-app 等
  - 选择合适的 UI 框架，比如 element-ui、ant-design-vue 等
  - 选择合适的状态管理工具，比如 vuex、redux 等
  - 选择合适的路由管理工具，比如 vue-router、react-router 等
  - 选择合适的打包工具，比如 webpack、rollup 等
  - 选择合适的代码检查工具，比如 eslint、stylelint 等
  - 选择合适的代码格式化工具，比如 prettier、editorconfig 等
  - 选择合适的 git 提交规范工具，比如 commitizen、commitlint 等
  - 选择合适的单元测试工具，比如 jest、mocha 等
  - 选择合适的 e2e 测试工具，比如 cypress、nightwatch 等
  - 选择合适的持续集成工具，比如 travis、github actions 等
  - 选择合适的自动化部署工具，比如 pm2、docker 等
- 项目开发
  - 项目目录结构
  - 项目配置
  - 项目开发
  - 项目测试
  - 项目部署

## 16. 常见的数据可视化库

- ECharts：百度团队开发，封装了绝大多数常规 chart，用户通过配置 options 参数，就可很容易绘制指定图表。
  - 优点：学习门槛较低、图表丰富
  - 缺点：自由度较低、很难实现自定义图表
- antv.g2：蚂蚁金服团队开发，提供了更加友好的 API，支持 React、Vue、Angular 等框架。
  - 优点：自由度较高、可根据自己的 UI 需求，用 g2 做底层库，封装自己的 charts 库。
  - 缺点：学习成本稍高
- d3
  - 优点：更接近底层，d3 能直接操作 svg，所以拥有极大的自由度
  - 缺点：学习门槛较高，需要对 svg、canvas 等有一定了解，还要有可视化的设计能力

## 17. 怎么约定团队的代码规范

- 能统一编辑器最好，不能的话尽量不要太多种，一般就是 vscode 和 webstorm
- 电脑系统最好统一，比如 mac 或者 windows，因为不同系统下的换行符不一样，如果不能统一，需要在 setting.json 中配置换行符为 lf：`"files.eol": "\n"`
- 代码风格的统一使用 eslint，可以通过配置 .eslintrc.js 来统一团队的代码风格，常用的规范有 standard、plugin:react/recommended、plugin:react-hooks/recommended、plugin:prettier/recommended
- 代码格式化的统一使用 prettier，可以通过配置 .prettierrc.js 来统一团队的代码格式化
- 需要打开 eslint 的自动修复功能，这样可以在保存文件时自动修复代码风格问题
- 代码提交时使用 git hooks，校验代码风格，比如使用 husky 和 lint-staged
- 代码提交时还可以使用 commitizen 和 commitlint 来规范 commit message

## 18. 怎么提高开发效率

### 18.1. 工具

- chrome：翻墙、谷歌账号、谷歌插件
- vscode：常用插件(console-log-quickly、link-to-define、copilot)、快捷键
- mac
- 显示器双屏
- git 图形工具：sourceTree(提交代码灵活)
- 接口调试：postman(环境变量、脚本)
- 终端工具：cmder [wsl](https://docs.microsoft.com/en-us/windows/wsl/install-win10)
- 笔记：有道云、印象笔记、语雀、Typora、Notion
- 图床：[picGo](https://github.com/Molunerfinn/PicGo)
- 其他：whistle、nvm、FoxMail、Xftp、Xshell、[Snipaste](https://zh.snipaste.com/)(截图贴图)

### 18.2. 开发习惯

- 代码层面：可读性、可维护性
- 调试层面：只有一个原则，减少调试成本，如 whistle、真机调试等
- 平时习惯：chrome 书签、笔记、代码片段
- 其他方面
  - 精神状态：加强锻炼、身体是本钱
  - 沟通层面：尽量当面沟通、描述清楚问题（预期是什么样，当前是什么样，在什么场景下遇到了什么问题）

## 19. 单元测试

### 19.1. 单元测试的优缺点

- 优点
  - 保证代码质量、可维护性、可扩展性、可重用性、可读性、可信赖性、可靠性、可测试性、可调试性、可移植性、可安全性、可性能、可稳定性
  - 保证代码的正确性
  - 保证代码的健壮性
- 缺点
  - 代码量增加
  - 代码复杂度增加
  - 代码维护成本增加
  - 代码执行效率降低

### 19.2. 单元测试的分类

- 功能测试：测试代码的功能是否符合预期
- 性能测试：测试代码的性能是否符合预期
- 安全测试：测试代码的安全性是否符合预期
- 兼容性测试：测试代码的兼容性是否符合预期
- 压力测试：测试代码的压力是否符合预期
- 回归测试：测试代码的回归是否符合预期

### 19.3. 单元测试的工具

- jest: facebook 出品，功能强大，支持 react、vue、angular 等框架，支持 ts、js 等语言，支持多种测试框架，比如 mocha、jasmine 等
- mocha: nodejs 出品，功能强大，支持 ts、js 等语言，支持多种测试框架，比如 chai、should 等
- enzyme:
  - shallow：浅渲染，只渲染当前组件，不渲染子组件
  - describe：测试套件，用于组织测试用例
  - it：测试用例，用于测试某个功能
  - expect：断言，用于判断测试结果是否符合预期
  - test：测试用例，用于测试某个功能，第一个参数是测试用例的描述，第二个参数是测试用例的函数

### 19.4. 什么场景下会用到单元测试

- 重要的代码、业务
- 基础的 utils 组件
- 公共的组件

### 19.5. 单元测试的原则

- 测试覆盖率：测试覆盖率越高，代码质量越高
- 测试用例的设计：测试用例的设计要考虑到各种情况，比如边界值、异常值、特殊值等
- 测试用例的执行：测试用例的执行要考虑到各种情况，比如正常情况、异常情况、边界情况等

### 19.6. 项目中怎么搭配使用

- 项目中使用 jest，使用 jest-dom、jest-fetch-mock、jest-localstorage-mock 等插件
- 项目中使用 enzyme，使用 enzyme-adapter-react-16 等插件

## 20. MVC、MVVM

### 20.1. MVC

- MVC 是一种软件设计模式，它把一个应用程序分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）
- 模型（Model）：模型代表应用程序的数据部分，负责处理应用程序的数据逻辑，通常模型对象负责在数据库中存取数据
- 视图（View）：视图代表应用程序的用户界面（UI），负责将模型包含的数据显示给用户，并允许用户编辑数据
- 控制器（Controller）：控制器负责处理用户交互，从视图读取数据，控制用户输入，并向模型发送数据

MVC 的数据流向是单向的，即：视图 -> 控制器 -> 模型 -> 视图，这种单向的数据流向使得代码的可读性和可维护性都很高，常见的框架有：Angular、Vue、React

### 20.2. MVVM

- MVVM 是 Model-View-ViewModel 的缩写，它是一种用户界面架构模式，它将一个复杂的用户界面分为三个部分：模型（Model）、视图（View）和视图模型（ViewModel）
- 模型（Model）：模型代表应用程序的数据部分，负责处理应用程序的数据逻辑，通常模型对象负责在数据库中存取数据
- 视图（View）：视图代表应用程序的用户界面（UI），负责将模型包含的数据显示给用户，并允许用户编辑数据
- 视图模型（ViewModel）：视图模型负责处理用户交互，从视图读取数据，控制用户输入，并向模型发送数据

MVVM 的数据流向是双向的，即：视图 -> 视图模型 -> 模型 -> 视图模型 -> 视图。

在 vue 中：Model:指的是 js 中的数据，如对象，数组等等。View:指的是页面视图 viewModel:指的是 vue 实例化对象。通过双向绑定可以提升开发效率

vm 的作用是将视图和模型进行绑定，当视图发生变化时，vm 会自动更新模型，当模型发生变化时，vm 会自动更新视图，这种双向的数据流向使得代码的可读性和可维护性都很高

## 21. 代码为什么要重构，是怎么做的

### 21.1. 代码为什么要重构

- 维护角度：历史代码很难维护，一个文件几千行，产品要改一个需求，要改好几个文件，可能在不经意间就影响到其他功能
- 性能角度：有些历史逻辑越写越大，之前用的 react，发现很多 setState 都是在循环里面，层层嵌套，导致性能很差

### 21.2. 代码怎么重构

- 沟通
  - 先在组内讨论可行性，征得组长或 leader 的同意
  - 和产品同步，告知其本次重构的目的，以及可能会影响到的功能，征得产品的同意
- 开发前准备工作
  - 梳理业务，可以从历史需求文档以及历史代码中梳理出业务逻辑，要关注些个性化逻辑
  - 根据梳理的业务列出大纲以及改动点，再整理出一个技术方案
  - 找产品、测试、根据业务的重要性以及影响范围叫上相关的同事或者 leader，开技术评审会，同步技术方案
- 开发
  - 按照梳理的大纲或者技术方案，将代码进行拆分，拆分成一个个独立的组件
  - 尽量把展示组件和逻辑组件分开，逻辑组件只负责逻辑，展示组件只负责展示
  - 一些公共的逻辑可以抽离出来，放到公共组件中
  - 重要的逻辑需要写单元测试
  - 开发过程中，一些关键的点要记下来，自测阶段着重测试下

## 22. 说一下腾银财智这个项目

我刚进公司的时候，项目已经存在了。但当时项目的基础建设比较薄弱，比如说没有自动格式化、没有代码规范等

所以我在项目中做了一些的基础建设，比如说：引入了 eslint、prettier 等，然后写了 2 个 vscode 插件和一个 script 脚本用于提升团队的协作效率。

其中一个 vscode 插件是针对我们项目，在的 api 使用过程中，用的是字符串传参形式定义请求，但是字符串在 vscode 中是不能点击跳转的，所以我写了一个插件，可以识别请求中的字符串，然后点击跳转到项目中的 api 文件具体的行数

另一个 vscode 插件是 fork 已有的插件，在他的基础上添加了一些功能，提了 pr，但是作者没有合并，所以我就自己发布了一个，现在也在团队中使用

script 脚本是针对我们有一个微信原生小程序的项目，在切换环境的时候，需要手动修改 appid 和 project.config.json 文件，所以我在 package.json 中添加了一个 script 命令，可以接受一个参数，然后根据参数生成对应环境的 appid

另外做了一些优化工作，比如说 antd 和 webpack 的升级还有项目的重构从 react 到 vue 都是我们这个小组负责的。

因为后面一年做的是小组长，所以平时的工作还包括需求评审、分配任务、跟进任务、技术评审等等。这些工作对我也有很大的帮助，一方面是对工作时间的分配有了更好的把控，另一方面也提高了我的沟通能力，因为要对上对下还有跨部门的沟通

还有一个是思维的转变，以前收到一个需求，更多想的是怎么去完成、去实现，现在收到一个需求，想的是产品为什么要这么做，这样做有什么好处，有什么风险点，这样做会不会影响到其他功能，会不会有性能问题等等，这些都是我在做需求评审的时候要考虑的，更多的是从产品和用户的角度出发，看需求是否合理。

举个重构的例子：

我们业务线中，有一个早报模块，每天早上会有几十万的访问量。但是里面的代码可维护性很低，一个文件几千行，涉及好几个文件。产品提一个需求过来，以为只要半天，但是开发给出的规模是 1-2 天，如此下去，项目的可维护性会越来越差，所以我就在项目中做了重构

重构之前先征得产品的同意，告知其重构的好处以及风险点。产品同意之后，就从业务入手，要保证重构前后对业务没有影响。了解业务会从历史需求文档以及历史代码中梳理，着重关注一些个性化的逻辑。然后列出大纲以及改动点，再整理出一个技术方案。最后找产品、测试、根据业务的重要性以及影响范围叫上相关的同事或者 leader，开技术评审会，同步技术方案

在开发阶段就根据梳理的大纲或者技术方案，将模块进行拆分，拆分成一个个独立的组件。尽量把展示组件和逻辑组件分开，一些公共的逻辑可以抽离出来，放到公共组件中。开发过程中，看见之前不合理的地方就提出来，一起讨论，然后再做修改。一些关键的点会记下来，自测阶段重点关注

### 22.1. 对代码的质量如何把控

- 代码规范
  - 项目中引入了 eslint、prettier 等，保证代码的格式统一
  - 项目中引入了 commitlint、commitizen 等，保证 commit message 的规范
  - 项目中引入了 husky、lint-staged 等，保证代码提交前会做一些检查
- 开发阶段
  - 自测
  - 合并代码 review(包括 sourcetree 提交、gitlab 合并请求)
  - 代码 review
    - 简单过一下需求，看看有没有遗漏的点
    - 有没有不合理的地方
    - 代码是否规范、组件是否拆分合理
- 测试阶段
  - 测试
  - 测试用例

### 22.2. 你的工作中有哪些技术难点

- 业务
  - 业务的复杂度
  - 业务的个性化
  - 业务的变化
- 重构
  - 重构的时候，要保证重构前后对业务没有影响
  - 了解业务会从历史需求文档以及历史代码中梳理，着重关注一些个性化的逻辑
  - 重构的时候，要考虑到以后的扩展性，比如说，如果要新增一个功能，要考虑到这个功能是否会影响到重构后的代码
- 数据隔离
  - saas 项目中，每个客户的数据是隔离的，不能互相访问
  - 前端涉及到的数据隔离，主要是 cookie 和 localStorage，这两个数据是存储在浏览器中的，所以要做到数据隔离，就要保证 cookie 和 localStorage 的隔离

## 23. 你觉得你的优势是什么？劣势是什么？

- 优势
  - 有较强的学习能力，能够快速的学习新的技术
  - 有责任心，执行力比较强
  - 有团队协作意识
- 劣势
  - 有点强迫症，有时候会过于追求完美，导致效率降低
  - 会钻牛角尖，有时候会过度优化
  - 平时话比较少
  - 没有大厂的经验

## 24. 大前端和微前端

- 大前端
  - 相比于以前，现在前端的工作范围已经不仅仅局限于浏览器了，现在前端的工作范围已经扩展到了小程序、移动端、桌面端、服务端等等，还有些前端工具，比如说 webpack、babel、eslint 等等，都是前端的工具，所以我觉得大前端是一个比较合适的称呼
  - 还有 devops 的范畴，比如说前端的自动化测试、自动化部署等等
- 微前端
  - 微前端是相对于微服务的概念。后端基本都会采用微服务的架构，但前端却不一定需要微前端。要根据业务来决定是否需要微前端，如果业务比较简单，不需要微前端，如果业务比较复杂，可以考虑微前端的方案，有利于团队的协作，提高开发效率。
  - 常见的微前端的方案有 qiankun、single-spa、nx、module-federation 等等

## 25. nx 是什么

nx 是 monorepo 的一种实现，是一个工具，因为我们的应用越做越大，每次发版耗时很长，可能还会互相影响，所以在迁移到 vue 的时候考虑了 monorepo 的方案，我们把比较独立的模块单独作为一个子应用，可以做到独立开发，独立部署。提升了开发效率和构建速度，也降低了风险。

- 怎么搭建 nx
  - 安装 nx：npm install -g nx
  - 创建工作区：nx g @nrwl/workspace:workspace --preset=angular
  - 创建子应用：nx g @nrwl/angular:application --name=app1 --routing=true --style=scss
  - 开发时选择子应用：nx serve app1

## 26. 怎么实现 pdf 预览

- 用 iframe: 用 iframe 嵌入 pdf 的链接，但是这样会有跨域问题，所以需要后端做一些处理
- 服务端渲染: 用 puppeteer 渲染成图片，然后前端展示图片
- 通过第三方库: 如 pdf.js、pdfobject 等等

## 27. 说一下埋点怎么做的

我们埋点系统一共经历了 3 个版本。

- 调用后端接口埋点
  - 优点：简单
  - 缺点：接口调用耗时，影响用户体验
- 三方神策埋点
  - 优点：稳定，功能强大
  - 缺点：成本高，需要购买服务
- 自研的 sdk 埋点
  - 优点：成本低，功能可以自定义
  - 缺点：需要自己维护
  - 上报形式：通过 ajax 上报

sdk 埋点采用的是 SPM 即超级位置模型（Super Position Model），包含 A.B.C.D 四层级： A(应用站点)、B(页面)、 C(模块)、 D(模块内点位)。当触发事件时，更新对应层级位置的值，将当前的位置信息和事件信息一起发送给后端，后端根据位置信息，将事件信息存储到对应的位置信息中。这样就可以实现对事件的统计。

全局维护 2 个字段，一个 pre，一个 cur，pre 用来存储上一次的位置信息，cur 用来存储当前的位置信息。当触发事件时，更新 cur 的值，然后将 pre 和 cur 的值一起发送给后端，后端根据 pre 的值，将事件信息存储到对应的位置信息中。

当页面跳转时，更新 pre 的值，将 cur 的值赋值给 pre，cur 的值置空。在新页面中触发事件时，更新 cur 的值，然后将 pre 和 cur 的值一起发送给后端。

上报字段包括：

```js
{
  env_name: options.env_name, // dev,test,test2,test3,uat,prod
  device_id: '', // 设备浏览器id
  open_id: '',
  union_id: '',
  user_id: '', // 企微后台用户userId
  main_id: '', // 我们后台区别用户
  user_type: '', // 用户类型：企业员工、企业客户、潜在客户、游客
  identity: '', // 身份类型 非同事，同事，员工自己
  corp_id: '',
  staff_id: '',
  sub_session_id: '', // 隐藏后重新显示 会话子id
  event_type: '', // 事件类型
  page_desc: '', // 当前页面路径
  block_desc: '', // 模块
  button_desc: '', // button
  parameters: {}, // 附加参数
}
```

其中 page_desc 会记录当前的路由栈信息，后端根据路由栈信息，可以还原出用户的操作路径。

路由栈是通过监听路由变化，如：

- 监听浏览器关闭、刷新、location.href 跳转：`window.addEventListener('unload'`
- 监听路由变化：`router.beforeEach((to, from, next) => {}`
- 监听前进后退与 back forward go：`window.addEventListener('popstate'`
- 拦截路由 pushState 与 replaceState 添加 SPM 位置信息：`history.pushState = history.replaceState = function() {}`

### 27.1. 埋点数据的上报方式

- 通过 img 标签的 src 属性上报
- 通过 ajax 请求上报
- 通过 navigator.sendBeacon 上报
  - navigator.sendBeacon() 方法用于异步传输少量数据到 Web 服务器，即使在页面卸载之前。这个方法使用了 HTTP POST 请求，但是它的请求方式是 "fire-and-forget"，也就是说它不会等待服务器的响应，也不会在卸载之前等待数据传输完成。这个方法的主要用途是在用户关闭页面之前传输少量数据，比如统计数据或者广告点击数据。

### 27.2. 埋点数据丢失怎么解决

- 通过 navigator.sendBeacon 上报，因为它是异步的，不会阻塞页面卸载，所以不会丢失数据
- 通过 ajax 请求上报时，设置超时时间，超时后再次上报
- 通过 img 标签上报时，设置 onload 和 onerror 事件，如果失败了再次上报

## 28. 你的项目中遇到的最大的问题是什么，怎么解决的

- 项目问题
  - 出过一个线上问题，在做一个需求时候发现代码很难维护，于是提出想要重构，但当时刚进公司，对业务所有涉及的点还没有摸透，正好产品经理也是刚换一个人接手，导致重构之后我们遗漏了一个点导致用户数据异常，引起了客户的投诉反馈。
  - 我们有个线上 bug 群，当时问题反馈到群里发现是我负责的模块，就先主动认领一下 bug，然后积极的排查定位问题，并且找相关同学咨询，最后发现问题并且紧急修复
  - 解决后给客户一个反馈，解释一下问题原因
  - 经过这次就意识到了重构的重要性，后面几次重构都没有出现问题
- 技术难点
  - 第一次引入 jotai 状态库的时候，发现了 2 个问题。一个是会自动缓存状态，导致二次进入页面状态没有重置。另一个是第一次进入页面会有一瞬间的白屏，后面又不会了。
  - 当时通过代码调试，发现 jotai 会自动缓存状态，所以就在页面离开的时候，清除缓存的状态。
  - 解决第二个问题，比较棘手。因为从代码上没看出明显的问题。因为 jotai 比较新，所以能查阅的资料也不多。后面通过查看 github 的 issue，发现有人提出了类似的问题，最终看了下源码，发现 jotai 是通过 react 的 context 来实现的，所以在页面刚进入的时候，context 还没有初始化，所以会有一瞬间的白屏。所以最后的解决方案是，通过 react 的 suspense 来解决这个问题。在页面刚进入的时候，先显示一个 loading，然后等待 context 初始化完成，再显示页面。
  - 为什么会引入这个新的状态库：因为当时项目中对状态管理用的不多，很多人都是通过 props 传递属性的，导致跨层级的属性一层传一层，这样后期就很难维护。所以就想引入一个状态库，来统一管理状态，方便后期维护。当时看到了 jotai，是以原子的方式来管理状态，相比于 redux，更加轻量，侵入性更小，所以就引入了。
- 管理层面
  - 跟产品有分歧。主要是需求合理性的问题
  - 和组员有分歧。有次产品提了一个需求，我们在评审的时候，我组里的一个组员直接和产品吵起来了，互掐的那种。后来我去了解了一下，组员觉得需求不合理，所以不想做。但其实这个需求，之前已经合产品还有前后端测试同学初评过一次了，并没有觉得哪里不合理的地方。后来沟通后发现是因为这个组员上次在重构这个业务模块的时候，没有考虑到扩展性，导致这次的需求实现比较困难，所以才不想做。后来我们一起讨论了一下，最后达成了一致，我们要从产品和用户的角度去考虑，如果从产品或者用户的角度去考虑，需求是合理的，我们就可以接，那实现的时候有什么困难点可以提出来一起解决。
  - 需求延期相关。有次一个比较重要的需求，由于我组里有个同学进度比较慢，导致最后上线延期了。组员的态度其实没有问题，是他在评估工时的时候，评少了，导致后续无法按时完成

## 29. 写一个组件，你会考虑哪些方面？

- 单一职责原则，一个组件只做一件事
- 组件的可复用性，尽量减少重复代码
- 组件的可维护性，尽量减少耦合度，提高可读性
- 组件的可扩展性，尽量减少对组件的修改，提高组件的可扩展性
- 控制输入，尽量减少组件的异常情况

## 30. 怎么看待华为 od 的，为什么做这么久前端了还来华为 od?

- 一直都比较喜欢华为这个企业，但华为社招已经不招正式员工了，非应届生进入华为只有通过 od 这个途径，之前也投过，但是没过
- 外包公司里面我只考虑了 od，因为我感觉 od 是外包里面的天花板，而且听说里面的技术氛围很好，每年都有名额可以转为正式员工

### 30.1. 你对华为的认识，对当前岗位的了解

- 我认为华为是一个很好、很良心的企业，业务范围非常广，涉及到手机、平板、路由器、服务器、软件、云服务、智能家居这些。我也很喜欢华为的产品，用的手机和平板都是华为的。
- 我也非常希望自己能够进入华为，但华为社招已经不招正式员工了，非应届生进入华为只有通过 od 这个途径，之前也投过，但是没过
- 都说华为是狼性文化，敏感性、团队性、不屈不挠性，我觉得这些都是很好的品质，我也希望自己能够有这些品质

我对 od 的了解是，od 是华为的外包公司，但是 od 里面的技术氛围很好，每年都有名额可以转为正式员工，所以我也很想进 od。

## 31. 能否接受公司的工作时间？加班？

- 可以的。我认为企业和员工是双向选择的，所以既然选择了，就表明了认同，那工作时间肯定是可以接受并遵守的
- 程序员基本都加过班，我也不排斥加班，只要不是无意义的加班，我都是可以接受的

## 32. 你的职业规划是什么？

- 我的目标是能够做到学以致用，所以接下来想要学习些后端、数据库、运维等相关的知识，然后在工作中能够运用到

## 33. 你的期望薪资是多少？

我目前是 23 \* 15，所以期望下份薪资能比这个高

- od
  - 但听朋友说 od 是面试后会定级，然后按定级给薪资，所以也看我的面试表现以及面试官的评价，综合考虑
- 其他
  - 但最后可以根据面试表现以及公司的福利和预算来综合考虑

## 34. 你有什么问题要问我们吗？

- od
  - 每年有多少名额可以转正式员工？
  - 不知道我这次如果能进公司，负责的会是哪一块的业务？
- 其他
  - 可以介绍下整体的福利待遇吗 - hr
  - 加班情况、对应补偿？ - hr
  - 年终奖 - hr
  - 五险一金 - hr
  - 试用期长度以及薪资发放比例 - hr
  - 其他补贴，餐补、交通补助？ - hr
  - 绩效、工资里面含绩效吗 - hr
  - 年假 - hr
  - 晋升机制、末位淘汰
  - 主要技术栈是什么？
  - 团队规模
  - 公司研发部门的技术氛围怎么样
  - 这次招聘是因为扩招吗
  - 团队氛围、技术氛围、技术分享、团建
  - 上午跟 hr 沟通了，提到我们有很多业务线，不知道我这次如果能进公司，负责的是哪一块的业务
  - 公司的研发流程是什么样的
  - 公司在行方有多少人 - 驻场
  - 在行方维护的是自己的项目还是银行的项目 - 驻场
  - 您目前是在行方还是在公司 - 驻场
  - 需求开发上线的流程是怎么样的 - 驻场
  - 项目周期的稳定性怎么样 - 驻场
  - 如果项目结束那人员怎么规划 - 驻场

## 35. 谈薪技巧

你好，我是\*\*\*，上午您联系我谈薪，我说下午给您答复。

首先是感谢公司对我的认可，在面试环节也谈过我的期望薪资是 20。我目前呢也确实收到了一个厦门 20k 的 offer，但相比起来，还是更希望能够进入福龙马集团，因为福龙马是龙岩的企业，我老家也是龙岩的，有这个机会也想为家乡的企业做出点贡献，如果能够进入公司的话，我也会尽我的能力为公司创造价值。所以在薪资方面，想问下是否还有可以申请的空间，上午您说的是 16.5，如果能有 17.5 的话，我这边是可以接受的。

目前收到的 offer 是厦门的海辰储能，在同安区，是朋友介绍的

另外想了解下我们的薪资是包括绩效还是不包括绩效的

有每年普调或者晋升的机会吗

我这边的入职时间需要到下周一，3 月 27 号，不知道公司这边能否接受

好的 谢谢 那就麻烦您了
