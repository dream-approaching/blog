---
title: 基本
group:
  title: 算法
  order: 30
---

<!-- TOC -->

- [算法](#算法)
  - [1. 时间复杂度 & 空间复杂度](#1-时间复杂度--空间复杂度)
    - [1.1. 时间复杂度](#11-时间复杂度)
    - [1.2. 空间复杂度](#12-空间复杂度)
  - [2. 常见算法解决思路](#2-常见算法解决思路)
    - [2.1. 二分查找](#21-二分查找)
    - [2.2. 双指针](#22-双指针)
    - [2.3. 动态规划](#23-动态规划)
    - [2.4. 贪心算法](#24-贪心算法)
    - [2.5. 分治算法](#25-分治算法)
    - [2.6. 回溯算法](#26-回溯算法)
    - [2.7. 哈希算法](#27-哈希算法)

<!-- /TOC -->

# 算法

## 1. 时间复杂度 & 空间复杂度

### 1.1. 时间复杂度

时间复杂度是一个函数，它定性描述了该算法的运行时间。它是关于问题规模 n 的函数，通常用大 O 符号表示，即 `O(f(n))`。它表示随着 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作渐进时间复杂度，简称时间复杂度。

常见的时间复杂度有：

- 常数阶 `O(1)`: 只要算法中不存在循环语句等，时间复杂度都是 `O(1)`。
- 对数阶 `O(logN)`: 每次循环都会将问题规模减半，所以时间复杂度为 `O(logN)`。一般对数阶都是以 2 为底的，即 `O(log2n)`。
  ```js
  for (let i = 1; i < n; i *= 2) {
    // ...
  }
  ```
- 线性阶 `O(n)`: 执行时间与问题规模 n 成正比。
  ```js
  for (let i = 0; i < n; i++) {
    // ...
  }
  ```
- 线性对数阶 `O(nlogN)`: 线性阶 `O(n)` 与对数阶 `O(logN)` 的结合。
  ```js
  for (let i = 1; i < n; i++) {
    for (let j = 1; j < n; j *= 2) {
      // ...
    }
  }
  ```
- 平方阶 `O(n^2)`: 两层循环。

  ```js
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      // ...
    }
  }
  ```

- 立方阶 `O(n^3)`: 三层循环。
  ```js
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      for (let k = 0; k < n; k++) {
        // ...
      }
    }
  }
  ```
- k 次方阶 `O(n^k)`: k 层循环。
  ```js
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      for (let k = 0; k < n; k++) {
        for (let l = 0; l < n; l++) {
          // ...
        }
      }
    }
  }
  ```
- 指数阶 `O(2^n)`: 递归。
  ```js
  function fib(n) {
    if (n <= 1) return n;
    return fib(n - 1) + fib(n - 2);
  }
  ```

### 1.2. 空间复杂度

空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势。

空间复杂度比较常用的有

- O(1)：如果所需要的临时空间不随着变量 n 的大小而变化

  ```js
  let i = 0;
  let j = 0;

  ++i;
  j++;

  console.log(i, j);
  ```

- O(n): 如果所需要的临时空间随着变量 n 的大小而变化

  ```js
  let arr = new Array(n);

  for (let i = 0; i < n; i++) {
    arr[i] = i;
  }

  console.log(arr);
  ```

- O(n²): 如果所需要的临时空间随着变量 n 的平方而变化

  ```js
  let arr = new Array(n);

  for (let i = 0; i < n; i++) {
    arr[i] = new Array(n);
    for (let j = 0; j < n; j++) {
      arr[i][j] = i * j;
    }
  }

  console.log(arr);
  ```

## 2. 常见算法解决思路

- 二分查找
- 双指针
- 滑动窗口
- 动态规划
- 贪心算法
- 分治算法
- 回溯算法

### 2.1. 二分查找

二分查找是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。

二分查找的时间复杂度为 `O(logn)`，空间复杂度为 `O(1)`。

### 2.2. 双指针

双指针是一种使用两个指针遍历数组的技巧。它可以用来解决一些数组类的问题，比如：

- 两数之和
- 三数之和
- 两数平方和
- 反转字符串中的元音字母
- 接雨水

### 2.3. 动态规划

动态规划是一种将复杂问题分解为更小的子问题来解决的优化技术。它将问题分解为子问题，通过求解子问题的解来求解原问题的解。动态规划的关键是找到子问题的重叠性质，从而减少计算量。

用动态规划解决问题时，要遵循三个重要步骤：

- 定义子问题
- 实现需要反复执行而解决子问题的部分
- 识别并求解出边界条件

能用动态规划解决的一些著名问题：

- 最长公共子序列
- 背包问题
- 硬币找零
- 矩阵链乘法

### 2.4. 贪心算法

贪心算法是一种在每一步选择中都采取在当前状态下最好或最优的选择，从而希望导致结果是全局最好或最优的算法。贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。

能用贪心算法解决的一些著名问题：

- 硬币找零
- 买卖股票的最佳时机
- 分发饼干
- 跳跃游戏
- 加油站

### 2.5. 分治算法

分治算法是一种将问题分成一些小的问题然后递归求解的算法，而治的阶段则将分的阶段得到的各答案“修补”在一起，得到原问题的解。

能用分治算法解决的一些著名问题：

- 汉诺塔
- 快速排序
- 归并排序
- 线性时间选择

### 2.6. 回溯算法

回溯算法是一种通过穷举所有可能情况来找到所有解的算法。如果一个候选解最后被发现并不是可行解，回溯算法会舍弃它，并在前面的一些步骤做出一些修改，并重新尝试找到可行解。

能用回溯算法解决的一些著名问题：

- 八皇后问题
- 0-1 背包问题
- 求解数独
- 括号生成

### 2.7. 哈希算法

哈希算法是一种将任意长度的二进制值串映射为固定长度的二进制值串的算法，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值。

**特点**:

1.  从哈希值不能反向推导出原始数据
2.  对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同
3.  哈希算法的执行效率很高，针对较长的文本，只需要很短的时间就可以计算出哈希值

**著名的 hash 算法**:

- MD5: 128 位, 用于文件校验。128 位是二进制位数，而不是十六进制位数，所以 MD5 的十六进制表示是 32 位
- SHA1: 160 位, 用于数字签名等领域
- SHA256: 256 位
- SHA512: 512 位

**hash 算法的应用**: 文件校验、 数字签名、 密码加密、 鉴权协议
